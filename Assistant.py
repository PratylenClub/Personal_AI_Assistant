from scipy.spatial.distance import cosinefrom random import choiceimport shelveTIME_OUT_CONSTANT = 10PHRASE_TIME_LIMIT = 30CENTROID = "centroid"WEIGHT = "weight"TRIGGER_SENTENCES = "Trigger sentences"ACTION = "Action"PARAMETERS = "Parameters"class personal_assistant:    def __init__(self,        word2vec_model,        pyttx_engine,        speech_recognition_microphone,        speech_recognizer,        actions_dict,        trigger_dict,        confirmation_threshold,        centroid_shelve_file_name        ):        """        This class creates a simple personal assistant        :param word2vec_model: Word2Vect gensim model        :param pyttx_engine: pyttx voice synthesizer engine         :param speech_recognition_microphone: microphone engine from speech recognition library        :param speech_recognizer: Speech recognizer engine from speech recognizer library        :param actions_dict: Dictionary of actions. Each entry corresponds to a possible action. The key is the name of the action, and the value is another dictionary with the following format: {"Parameters": tuple or dictionary of other possible parameters required for the action, "Action": Function}        :param trigger_dict: Dictionary of triggers. Each entry corresponds to a possible action. The key is the name of the action, and the value is a list of strings containing each a possible trigger sentence.        :param confirmation_threshold: Distance threshold between order and action beyond which the assistent ask for a confirmation        :param centroid_shelve_file_name: File name for a shelve of actions and their corresponding centroid trigger and weight (trained)        """        self.w2v_model = word2vec_model        self.pyttx_voice = pyttx_engine        self.sr_mic = speech_recognition_microphone        self.sr_recognizer = speech_recognizer        self.actions_dict = actions_dict        self.trigger_dict = trigger_dict        self.confirmation_threshold = confirmation_threshold        self.centroid_shelve_file_name = centroid_shelve_file_name        self.fill_centroid_shelve()        self.alive = True            def fill_centroid_shelve(self):        centroid_shelve = shelve.open(self.centroid_shelve_file_name, writeback=True)        for action in self.trigger_dict:            if action not in centroid_shelve.keys():                centroid_shelve[action] = {CENTROID: self.compute_action_centroid_trigger(self.trigger_dict[action]),                                            WEIGHT:self.compute_actions_centroid_triggers_weight(self.trigger_dict[action])}                centroid_shelve.sync()        centroid_shelve.close()    def compute_actions_centroid_triggers_weight(self, trigger_sentences):        return len(trigger_sentences)    def compute_action_centroid_trigger(self,trigger_sentences):        collapsed_sentences = " ".join(trigger_sentences)        return self.compute_sentence_centroid(collapsed_sentences)    def speak(self,text):        self.pyttx_voice.say(text)        self.pyttx_voice.runAndWait()    def active_listen(self):        with self.sr_mic() as microphone:            audio = self.sr_recognizer.listen(microphone,timeout=TIME_OUT_CONSTANT, phrase_time_limit=PHRASE_TIME_LIMIT)        msg = ""        try:            msg = self.sr_recognizer.recognize_google(audio)#,language="fr-FR")             print(msg.lower())        except sr.WaitTimeoutError:            pass        except sr.UnknownValueError:            pass#print("Google Speech Recognition could not understand audio")        except sr.RequestError as e:            self.speak("Could not request results from Google STT. Check your connection! {0}".format(e))        except:            self.speak("Something it is Wrong! It hurts! Wrong! Wrong! Wrong!")        finally:            return msg.lower()    def compute_sentence_centroid(self, sentence):        list_of_words_in_order = [w for w in sentence.split() if w in self.w2v_model.vocab]        mean_vector = self.w2v_model[list_of_words_in_order].mean(0)        return mean_vector    def choose_best_action(self, sentence):        min_distance = 3        max_weight = 0        best_matching_action = None        centroid_shelve = shelve.open(self.centroid_shelve_file_name)        current_sentence_centroid = self.compute_sentence_centroid(sentence)        for action,centroid_weight in centroid_shelve.iteritems():            distance = cosine(centroid_weight[CENTROID],current_sentence_centroid)            print action,distance            if distance < min_distance:                min_distance = distance                max_weight = centroid_weight[WEIGHT]                best_matching_action = action            elif distance == min_distance:                if centroid_weight[WEIGHT] > max_weight:                    best_matching_action = action                    max_weight = centroid_weight[WEIGHT]        return current_sentence_centroid, best_matching_action, min_distance    def ask_confirmation(self,best_matching_action):        alternative_formulation = choice(self.trigger_dict[best_matching_action])        self.speak("Excuse me, I didn't understand your request very well. Do you want me to "+alternative_formulation)        answer = self.active_listen()        if "no" in answer:            self.speak("Please reformulate your request.")            return 0        if "yes" in answer:            self.speak("Ok")            return 1    def learn_sentence(self,action,current_sentence_centroid):        centroid_shelve = shelve.open(self.centroid_shelve_file_name,writeback=True)        centroid_shelve[action][CENTROID] *= centroid_shelve[action][WEIGHT]        centroid_shelve[action][CENTROID] += current_sentence_centroid        centroid_shelve[action][WEIGHT] += 1        centroid_shelve[action][CENTROID] /= centroid_shelve[action][WEIGHT]        centroid_shelve.sync()        centroid_shelve.close()    def execute_action(self,action):        parameters = self.actions_dict[action][PARAMETERS]        function = self.actions_dict[action][ACTION]        if isinstance(parameters, tuple):            function(self,*parameters)        if isinstance(parameters, dict):            function(self,**parameters)        print parameters,function    def interactive_step(self):        msg = self.active_listen()        current_sentence_centroid, best_matching_action, min_distance = self.choose_best_action(msg)        print current_sentence_centroid, best_matching_action, min_distance        if min_distance >= self.confirmation_threshold:            confirmation = self.ask_confirmation(best_matching_action)            if not confirmation:                return 0        self.learn_sentence(best_matching_action, current_sentence_centroid)        self.execute_action(best_matching_action)        return 1    def interactive_loop(self):        while self.alive:            self.interactive_step()            